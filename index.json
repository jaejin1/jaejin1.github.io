[{"categories":null,"content":"Jaejin Lee developer 👨‍💻 updated: Jan 09, 2021 ","date":"2021-01-09","objectID":"/about/:0:0","tags":null,"title":"About Jaejin","uri":"/about/"},{"categories":null,"content":"Work History 🔥 ","date":"2021-01-09","objectID":"/about/:1:0","tags":null,"title":"About Jaejin","uri":"/about/"},{"categories":null,"content":"Cloud Engineer @ DreamusCompany(FLO) 2020.2.17 ~ Present ","date":"2021-01-09","objectID":"/about/:1:1","tags":null,"title":"About Jaejin","uri":"/about/"},{"categories":null,"content":"Junior Software Developer @ ICONLOOP 2018.10 ~ 2020.2.14 ","date":"2021-01-09","objectID":"/about/:1:2","tags":null,"title":"About Jaejin","uri":"/about/"},{"categories":null,"content":"Intern @ ICONLOOP 2018.07 ~ 2018.09 ","date":"2021-01-09","objectID":"/about/:1:3","tags":null,"title":"About Jaejin","uri":"/about/"},{"categories":null,"content":"Undergraduate Research Assistant @ UNClab 2016.06 ~ 2018.06 ","date":"2021-01-09","objectID":"/about/:1:4","tags":null,"title":"About Jaejin","uri":"/about/"},{"categories":null,"content":"Education 🎓 2013-2019 Hongik University Computer Information Communications Engineering ","date":"2021-01-09","objectID":"/about/:2:0","tags":null,"title":"About Jaejin","uri":"/about/"},{"categories":null,"content":"Links 🔗 Github https://www.github.com/jaejin1 Blog https://jaejin1.github.io/ Linkedin https://www.linkedin.com/in/jaejin-lee-425161173/ Thanks for reading! 👋 ","date":"2021-01-09","objectID":"/about/:3:0","tags":null,"title":"About Jaejin","uri":"/about/"},{"categories":["os","linux"],"content":"파티션이란 연속된 저장 공간을 하나 이상의 연속되고 독립된 영역으로 나누어서 사용할 수 있도록 정의한 규약.","date":"2020-06-28","objectID":"/partition/","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"파티션이란 연속된 저장 공간을 하나 이상의 연속되고 독립된 영역으로 나누어서 사용할 수 있도록 정의한 규약. partitionpartition \" partition 파티션을 나누기 위해서는 저장장치에 연속된 공간에 있어야한다. 하나의 하드디스크에는 여러 개의 파티션을 나눌 수 있지만, 두 개의 하드디스크를 가지고 하나의 파티션을 만들 순 없다. ","date":"2020-06-28","objectID":"/partition/:0:0","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"사용 용도 하나의 물리적인 디스크를 여러 논리 영역으로 나누어 관리를 용이하게 함. OS영역과 Data 영역으로 나누어 OS 영역만 따로 포맷 및 관리를 하기 위해 사용 여러 OS를 설치하기 위해 사용 하드 디스크의 물리적인 배드 섹터로 특정 영역을 잘라서 사용하기 위해 사용한다. ","date":"2020-06-28","objectID":"/partition/:1:0","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"partition vs volume 볼륨은 OS나 Application등에서 이용할 수 있는 저장공간, 즉 섹터의 집합이다. 연속된 공간이 아니여도 볼륨으로 볼 수 있다. 즉 2개의 하드디스크를 사용하는 경우 하나의 하드디스크처럼 인식하여 사용할 수 있다. 보통 partition에 FS를 설정해주면 volume으로 보기에 partition역시 volume으로 볼 수 있다. hard diskhard disk \" hard disk ","date":"2020-06-28","objectID":"/partition/:2:0","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"MBR Master Boot Record 각 boot record는 각 partition의 첫 번째 섹터에 위치하며, 주로 해당 partition의 설치된 OS를 부팅하는 역할을 하게 된다. 즉 OS 실행을 위한 boot loader를 호출하는 것이다. partition을 나누지 않은 경우라면 boot record는 MBR에 있을 것이다. 단일 partition을 사용하는 경우 (플로피) boot record는 1개만 있을 것이므로 MBR이 필요없다. MBRMBR \" MBR MBR 호출과정 MBR 호출과정MBR 호출과정 \" MBR 호출과정 ","date":"2020-06-28","objectID":"/partition/:3:0","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"linux partition Primary partition 주 영역 파티션 4개까지 생성가능 (1개 ~ 4개) Extend partition 확장 영역 파티션 1개 까지 생성가능 Ligical partition 논리 영역 파티션 SCSI 한 개의 총 partition 15개만 넘지 않게 사용가능 12개 이상은 좋지 않다고함 ","date":"2020-06-28","objectID":"/partition/:4:0","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"실습 ","date":"2020-06-28","objectID":"/partition/:5:0","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"파티션 나누기 aws에 ec2하나 띄워놓고 파티션을 나눠보장 먼저 파티션할 volume을 하나 생성하고 해당 ec2와 연결한다. 16GB짜리 disk를 연결했다. diskdisk \" disk $ fdisk -l fdisk -lfdisk -l \" fdisk -l 파티션 생성을 위해 파티션 설정으로 들어가자. $ fdisk /dev/xvdd partition 설정partition 설정 \" partition 설정 Primary 2GB Extended 4GB Logical 2GB Logical 2GB 사용안함 10GB 로 설정해보자. 먼저 2G 짜리 Primary 파티션을 만들기 위해 n 입력 partition 설정partition 설정 \" partition 설정 다음 primary 파티션을 생성해야하므로 p를 입력 순서대로 partition 번호는 1, sector 시작은 default, primary를 2GB로 설정하기위해서 last sector는 +2G 로 설정했다. partition 설정partition 설정 \" partition 설정 설정이 완료되었고 다시 p를 입력해 확인해보면 생성된 것을 확인 할 수 있다. partition 설정partition 설정 \" partition 설정 primary를 생성 했으므로 extended 파티션을 생성해보자. 똑같이 n 명령으로 생성하자. partition 설정partition 설정 \" partition 설정 xvdd2 이름으로 4GB Extended 파티션이 생성된 것을 확인 할 수 있다. 이제 Extended 파티션에 2개의 logical 파티션을 생성해보자. Extended 파티션을 생성하고 n 명령어를 입력하면 extended 대신 logical이 보일 것이다. partition 설정partition 설정 \" partition 설정 이제 2개의 logical 파티션을 생성하자 partition 설정partition 설정 \" partition 설정 2개째 설정하는 단계에서 Value out of range 에러가 발생했는데 Extended 파티션을 4GB로 설정했지만 완벽히 4GB가 아닐꺼라 남은 용량이 2GB보다 적어서 발생하는 에러 일 것이므로 default로 설정해주었더니 잘 할달 받은 것을 볼 수 있다. partition 설정partition 설정 \" partition 설정 w 명령으로 저장한다. partition 설정partition 설정 \" partition 설정 혹시 모르니 partprobe 명령으로 os에게 변경사항을 알려준다. $ partprobe 다시 확인하면 잘 나눠진것을 볼 수 있다. partition 설정partition 설정 \" partition 설정 ","date":"2020-06-28","objectID":"/partition/:5:1","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"파일 시스템 설정 파티션 생성을 완료하면 물리적인 공간만 나눠놓았고 파일시스템을 지정해줘야한다. ext4 파일 시스템으로 /dev/xvdd1에 적용한다. $ mkfs.ext4 /dev/xvdd1 fs 설정fs 설정 \" fs 설정 xvdd5, xvdd6도 설정해주자. xvdd5는 ext4로 , xvdd6은 ext3으로 설정해봤다. fs 설정fs 설정 \" fs 설정 ","date":"2020-06-28","objectID":"/partition/:5:2","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"마운트 파일시스템 설정까지 해줬으니 마운트를 해줘서 파티션한 공간을 사용해보자. /dev/xvdd1, /dev/xvdd5, /dev/xvdd6 을 연결하기 위해 3개의 마운트 포인트가 필요하다. mount 설정mount 설정 \" mount 설정 mount 설정mount 설정 \" mount 설정 마운트가 잘 된것을 볼 수 있고 user를 할당해서 home 디렉토리로 설정해보장 user 설정user 설정 \" user 설정 $ tail /etc/passwd user 설정user 설정 \" user 설정 mount 확인mount 확인 \" mount 확인 ","date":"2020-06-28","objectID":"/partition/:5:3","tags":["os","linux","filesystem"],"title":"Partition","uri":"/partition/"},{"categories":["os","linux"],"content":"sector란 물리 디스크에 입출력을 요청하는 최소 단위이다.","date":"2020-06-28","objectID":"/sector/","tags":["os","linux","setor"],"title":"Sector","uri":"/sector/"},{"categories":["os","linux"],"content":"sector란 물리 디스크에 입출력을 요청하는 최소 단위이다. 전통적인 하드 디스크는 512 Byte 크기의 sector들로 구성 되어 있다고 한다. 큰 데이터에 접근 하고자 할때 sector의 크기가 작으면 많은 입출력 요청이 발생해서 디스크 에서는 퍼포먼스를 올리기 위해 sector 자체 크기를 늘리고자 했다. 파일의 크기가 작아 하나의 sector를 채우지 못하는 파일들은 0으로 나머지 sector 부분을 보유하고 있다. 또한 한 sector에 동시에 2 종류의 정보는 들어 갈 수 없다. 2011년 1월에 모든 하드 디스크 제조 업체가 sector의 크기를 4096 KByte를 표준으로 하는 것에 합의 했다는데 밑의 사진만 봐도 512 bytes로 나온다. sector sizesector size \" sector size 그 이유가 물리적으로는 4096 Byte인 것으로 입출력을 하지만 하드 디스크에 내장된 컨트롤러가 논리적으로 sector의 크기가 512Byte인 것과 같이 advanced format의 디스크가 나왔다고 한다. 실제 물리 디스크에 입출력을 요청하는 단위를 물리 sector 라 부르고 4096 Byte, 디스크 상단에 에뮬레이션 되는 단위를 논리 sector 라 하고 512 Byte이다. ","date":"2020-06-28","objectID":"/sector/:0:0","tags":["os","linux","setor"],"title":"Sector","uri":"/sector/"},{"categories":["os","linux"],"content":"디스크 구조 ","date":"2020-06-28","objectID":"/sector/:1:0","tags":["os","linux","setor"],"title":"Sector","uri":"/sector/"},{"categories":["os","linux"],"content":"LBA방식 현재의 하드 디스크는 LBA방식으로 접근하는 것이 보통이다. 이것은 하드 디스크의 전체 sector에 0부터 sector번호를 붙여서 이 번호를 이용해 접근하는 방식이다. sector번호와 물리적 sector위치를 짝 지우는 일은 하드 디스크 컨트롤러에 내장된 펌웨어가 담당한다. sectorsector \" sector partition 포스트에서 나누었던 partition을 그대로 가져왔다. 각 파티션을 보면 시작점과 종료점이 sector 번호로 표시된다. /dev/xvdd1 은 2048 sector 부터 시작해 0~1047 sector는 파티션으로 사용되지 않음을 볼 수 있다. 디스크의 처음에 MBR이 있고, 그 뒤에 GRUB의 스테이지 1.5가 기록된다고 한다. ","date":"2020-06-28","objectID":"/sector/:1:1","tags":["os","linux","setor"],"title":"Sector","uri":"/sector/"},{"categories":["os","linux"],"content":"4KB sector disk 아까 위에서 기존의 하드 디스크는 1sector의 사이즈가 512Byte로 정해져 있다고 했다. 또, 물리적으로는 4KB씩 읽고쓰는데 논리적으로 512Byte로 에뮬레이션 하는 방식으로 되어 있다고도 했다. 예로 /dev/xvdd1이 2048 sector부터 시작한다면 256번째 4KB sector 시점과 일치한다. 파티션의 sector 수도 8의 배수이므로 파티션의 종료 위치도 딱 4KB sector의 마지막 지점이 된다. 장래에 4KB sector를 채용한 하드가 늘어날 것을 고려해 기본적으로 파티션의 시작 지점과 사이즈는 논리 sector 수로 생각한 8의 배수로 준비하는게 좋다. 이 작업을 파티션 정렬(alignment) 라고 한다. ","date":"2020-06-28","objectID":"/sector/:1:2","tags":["os","linux","setor"],"title":"Sector","uri":"/sector/"},{"categories":["os","linux"],"content":"파티션 정렬 파티션 정렬의 설명을 좀 더 추가하자면 사진의 0~62 sector들이 있고 그 뒤에 63번 sector부터 파티션이 시작되는 것을 볼 수 있는데, 논리적으로 봤을때는 데이터가 잘 위치한 것으로 보이지만 물리적 섹터의 경우 경계에 맞물려 데이터가 담긴 블록이 위치하게 된다. naver cloudnaver cloud \" naver cloud sector크기가 4096 Byte일 때 512 Byte 크기의 sector크기로 에뮬레이션 하나 실제로 4096 Byte 크기의 sector단위로 입출력 되기 때문에 물리 sector의 8번, 9번 sector에 각각 접근해야한다. naver cloudnaver cloud \" naver cloud 다음과 같이 8번 물리 sector의 남은 512Byte 만큼을 indent 한다면 그림과 같다. 1개의 논리 sector만큼 indent하여 물리 섹터의 경계에 정렬한다. 따라서 9번 물리 sector에만 입출력을 요청하면 된다. 이렇게 물리 sector 경계에 맞춰주는 것이 파티션의 정렬이다. 즉 파티션 교체 할때 파티션 정렬을 안하면 디스크 I/O 지연이 발생하겠다. ","date":"2020-06-28","objectID":"/sector/:2:0","tags":["os","linux","setor"],"title":"Sector","uri":"/sector/"},{"categories":["os","linux"],"content":"FS는 `저장장치 내에서 데이터를 읽고 쓰기 위해 미리 정해진 약속` 이라고 볼 수 있다.","date":"2020-06-21","objectID":"/filesystem/","tags":["os","linux","filesystem"],"title":"FileSystem","uri":"/filesystem/"},{"categories":["os","linux"],"content":"FS는 저장장치 내에서 데이터를 읽고 쓰기 위해 미리 정해진 약속 이라고 볼 수 있다. 또한 컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체제를 가리킨다. ","date":"2020-06-21","objectID":"/filesystem/:0:0","tags":["os","linux","filesystem"],"title":"FileSystem","uri":"/filesystem/"},{"categories":["os","linux"],"content":"소개 파일 시스템은 일반적으로 크기가 일정한 블록들의 배열에 접근할 수 있는 자료 보관 장치 위에 생성되어 이러한 배열들을 조직함으로 파일이나 디렉터리를 만들며 어느 부분이 파일이고 어느 부분이 공백인지 구분하기 위하여 각 배열에 표시를 해둔다. 자료를 클러스터 또는 블록 이라고 불리는 일정한 단위에 새겨 넣는데 이것이 바로 파일 하나가 필요로 하는 디스크의 최소 공간이다. ","date":"2020-06-21","objectID":"/filesystem/:1:0","tags":["os","linux","filesystem"],"title":"FileSystem","uri":"/filesystem/"},{"categories":["os","linux"],"content":"분류 일반적인 파일 시스템 일반적인 FS는 하드디스크와 같은 저장장치에서 주로 사용된다. 그 종류를 간단히 보면 다음과 같다. FAT (File Allocation Table) FAT은 어느 영역에 파일이 속해 있는지, 공간에 여유가 있는지, 또 어디에 각 파일이 디스크에 저장되어 있는지에 대한 정보를 중심으로 하는 테이블을 이용하는 것에서 비롯한다. 상대적으로 간단한 파일 시스템. 성능은 상대적으로 다른 파일 시스템보다 좋지 않다. 너무나도 단순한 자료구조를 사용하고 조그만 파일이 많으면 공간 활용률이 적어지기 때문이다. FAT12, FAT16, FAT32, exFAT등 종류가 더 있다. HPFS (High Performance FileSystem) NTFS (New Technology FileSystem) FAT32의 약점을 보완하기 위해 개발된 FS 드라이브 최대용량 256TB 파일 하나당 저장할 수 있는 최대 크기 16TB 윈도우에서는 최적화 되어 있지만, MAC, android, linux와 같은 기기는 제한되어있음. UFS (Unix FileSystem) ext ext, ext2, ext3, ext4의 종류들이 있다. 리눅스용 파일 시스템 가운데 하나 로 오늘날 많은 리눅스 배포판에서 주 파일 시스템으로 쓰이고 있다. APFS 애플 파일 시스템은 애플에서 macOS, iOS, watchOS, tvOS등에서 범용으로 사용하고자 만든 FS Flash FileSystem Network FileSystem 네트워크 파일시스템은 원격에 위치한 파일시스템을 로컬 파일시스템처럼 이용할 수 있도록 개발한 프로토콜이다. 단순히 파일 공유가 아니라 NFS도 파일 시스템임을 인지 해야 하기 때문에 원격 파일시스템이 mount되면 mount 지점 아래 위치한 파일에 접근을 하는 경우 NFS가 파일시스템 레벨에서 system call을 받아 직접 네트워크 파일을 수신해 쓰거나 실행할 수 있도록 한다. Virtual FileSystem OS차원에서 가상 파일시스템이라는 상위 레벨의 파일시스템 인터페이스가 존재하기 때문에 응용프로그램에서는 아무 구분 없이 OS의 system call을 호출하면 커널은 미리 등록 되어 있는 파일시스템 함수를 호출해 같은 경과를 얻을 수 있다. ","date":"2020-06-21","objectID":"/filesystem/:2:0","tags":["os","linux","filesystem"],"title":"FileSystem","uri":"/filesystem/"},{"categories":["os","linux"],"content":"요소 ","date":"2020-06-21","objectID":"/filesystem/:3:0","tags":["os","linux","filesystem"],"title":"FileSystem","uri":"/filesystem/"},{"categories":["os","linux"],"content":"클러스터 클러스터는 파일을 저장하는 단위로 1개 또는 복수의 섹터로 이루어진다. 여러 개의 클러스터를 사용할 때 반드시 연결되어 있지 않다. 여기저기 흩어져 있어도, 그 위치와 순서를 기록한 FAT등에 의하여 관리되므로 한 번에 파일의 전체 내용을 읽을 수 있다. OS가 파일시스템 생성 시 저장장치의 크기를 고려해 클러스터의 크기를 조절한다. 저장장치의 크기 및 사용 용도에 따라 달라져야한다. OS에 의해 데이터를 읽고 쓰는 과정에서 파일시스템은 미리 정해져 있는 클러스터의 크기를 기본단위로 하여 읽고 쓰는 과정에서 파일시스템은 미리 정해져있는 클러스터의 크기를 기본단위로 하여 입출력을 하게 된다. 클러스터의 크기가 4096Byte라면 1Byte를 읽더라도 4096Byte를 읽어야한다. processprocess \" process 크기가 작은 파일을 저장할 경우 낭비되는 영역이 생기는데 이 부분의 공간은 사용이 불가능 해진다. 낭비되어도 성능적인 측면에서 I/O의 비용이 커서 요즘의 대용량 하드라면 성능을 위해 무시할 정도다 ","date":"2020-06-21","objectID":"/filesystem/:3:1","tags":["os","linux","filesystem"],"title":"FileSystem","uri":"/filesystem/"},{"categories":["os","linux"],"content":"파일 파일시스템은 결국 파일을 기록하기 위한 것이므로 파일을 이루는 구조와 관리할 수 있는 추가적인 방법을 제시한다. 파일은 속성을 기록하는 메타 데이터, 실제 데이터를 기록하는 데이터 영역으로 나뉜다. 파일 정보 요청 프로세스 파일정보요청 → Meta Data 로 파일 경로 요청을 보낸다. Meta Data → 요청 파일 경로 안내를 해준다. Meta Data로 부터 받은 경로로 실제 파일로 접근한다. 참고 https://blog.naver.com/bitnang/70183421214 ","date":"2020-06-21","objectID":"/filesystem/:3:2","tags":["os","linux","filesystem"],"title":"FileSystem","uri":"/filesystem/"},{"categories":["os"],"content":"Application memory 구조의 Heap과 Stack을 살펴보자","date":"2019-11-20","objectID":"/memory/","tags":["os","memory"],"title":"메모리 영역 Heap, Stack 살펴보기","uri":"/memory/"},{"categories":["os"],"content":"Application memory 구조의 Heap과 Stack을 살펴보자. memory 이전글에서 Process/Thread를 얘기할때 Memory에 대한 언급을 잠깐 했다. 여기서 사용하는 Memory는 Virtual Memory라고.. 모든 프로세스가 실제의 메모리를 사용하게 되면 용량 문제가 발생하기 때문에 페이징 기법과 가상메모리를 사용한다. 흔히 코드에서 출력하는 주소값들은 가상주소이다. ","date":"2019-11-20","objectID":"/memory/:0:0","tags":["os","memory"],"title":"메모리 영역 Heap, Stack 살펴보기","uri":"/memory/"},{"categories":["os"],"content":"1 페이징기법 계산기의 GUI가 있다고하자. +, -, *, % 등의 연산을 할때 이는 페이징 파일에 저장된다. 페이징 파일에 아직 동작하지 않은 주소를 저장 시켜서 잠시 가지고 있는것.. 이와같이 페이징 파일을 가지고 있기에 모든 프로세스가 더 적게 메모리를 사용하는 것이다. ","date":"2019-11-20","objectID":"/memory/:1:0","tags":["os","memory"],"title":"메모리 영역 Heap, Stack 살펴보기","uri":"/memory/"},{"categories":["os"],"content":"2 가상메모리 프로그램을 동작하면 가상 메모리 공간이 생성된다. 그 메모리 공간은 상위, 하위 메모리로 나눠진다. ","date":"2019-11-20","objectID":"/memory/:2:0","tags":["os","memory"],"title":"메모리 영역 Heap, Stack 살펴보기","uri":"/memory/"},{"categories":["os"],"content":"2.2 상위 메모리 Stack의 메모리 공간이 할당된다. 지역변수, 리턴값등을 저장.. 값이 싸다. 이유는 할당과 해제는 CPU 명령어 2개로 끝난다고 한다. (할당, 해제) 코드로 예를 들면 함수가 종료되면 함수에 있던 모든 변수가 Stack에서 Pop된다고 생각하면 된다. 함수가 사라지면 외부에서 참조 못하는 것처럼 여기서 학부시절에 그렇게 많이 들은 Stack Overflow, Underflow등이 일어나게 되는 것이다. ","date":"2019-11-20","objectID":"/memory/:2:1","tags":["os","memory"],"title":"메모리 영역 Heap, Stack 살펴보기","uri":"/memory/"},{"categories":["os"],"content":"2.3 하위 메모리 Heap이 생성된다. 프로그램이 동작할 때 필요한 데이터 정보를 임시로 저장. heap할당은 비싸다. C에서 보면 malloc(), free()등으로 조작가능. Go, Python같은 언어들은 자동으로 GC가 작동하기 때문에 개발자가 신경 안써도 되는 경우도 있다. 하지만 코드를 작성할때 신경써야하는 부분이 있을 수도 있는데 Go를 예로 들어보면 2.3.1 Go에서 heap Go에서 포인터를 사용하면 대부분 heap에 할당 된다고 한다. 가능한 안쓰는게 좋겠지..? 포인터를 사용하지 않고 값을 복사하는 것이 memory를 작게써 CPU 캐시 적중률이 오른다고한다. 또한 포인터를 포함하지 않는 메모리 영역은 GC가 생략할 수 있다. 반대로 포인터가 있으면 GC가 스캔 할 필요가 있다. 이렇게 GC가 돌면 메모리 상에 흩어진 영역을 계속 탐색하기 때문에 무거워 지기 때문에 개발자는 조금이라도 가볍게 개발하기 위해서는 알아야 하는 개념이다. ","date":"2019-11-20","objectID":"/memory/:2:2","tags":["os","memory"],"title":"메모리 영역 Heap, Stack 살펴보기","uri":"/memory/"},{"categories":["os"],"content":"갑자기 컴퓨터 구조에 대해서 정리해보고 싶어서 머리속에 있는것을 더해 끄적여본다.","date":"2019-11-06","objectID":"/computerstructure/","tags":["os","linux","socket"],"title":"Computer structure and socket","uri":"/computerstructure/"},{"categories":["os"],"content":"갑자기 컴퓨터 구조에 대해서 정리해보고 싶어서 머리속에 있는것을 더해 끄적여본다. 대학교에서 전공과목으로 컴퓨터 구조를 배웠지만 생각이 나지 않고 뭘배웠는지 기억을 못한다… 그나마 남아있는것을 정리하려고한다. ㅜㅜ.. 컴퓨터는 가장 크게 H/W, S/W로 나눌 수 있고 이를 좀더 자세히 나눠서 보자 ","date":"2019-11-06","objectID":"/computerstructure/:0:0","tags":["os","linux","socket"],"title":"Computer structure and socket","uri":"/computerstructure/"},{"categories":["os"],"content":"H/W 말그대로 하드웨어 물리적인 컴퓨터 자원을 말한다. CPU, GPU, RAM등등 본체에 꼽혀있는것들.. ","date":"2019-11-06","objectID":"/computerstructure/:1:0","tags":["os","linux","socket"],"title":"Computer structure and socket","uri":"/computerstructure/"},{"categories":["os"],"content":"S/W 소프트웨어는 물리적 반대로 논리적(Logical)하다 라고 많이 불리고 이는 IT쪽에서 Virtual과 비슷한 의미를 가진다. 더 작게 나눠보자 ","date":"2019-11-06","objectID":"/computerstructure/:2:0","tags":["os","linux","socket"],"title":"Computer structure and socket","uri":"/computerstructure/"},{"categories":["os"],"content":"Kernel 커널은 운영체제의 핵심 부분으로서, 운영체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러가지 서비스를 제공한다. 라고 위키백과에 나와있다. 간단히 말하면 이 커널 영역에서 흔히 하드웨어 장치에 필요한 Driver가 있어야 하고, 그에 따른 구성요소가 포함된다고 보면 될 것 같다. 예를들어 Disk라는 물리적인 저장공간을 가지고있고 이에 따른 Driver가 있고 이 Driver는 File System(NTFS) 구성요소와 연결 되고, File System은 우리가 흔히 쓰는 File과 연결되어 처리가 된다. 우리가 컴퓨터로 파일을 옮기고 삭제하는등의 행동을 취했을때 내부적으로는 File -\u003e File System -\u003e Driver -\u003e Disk 또는 SSD등 이렇게 이뤄지는 것이당 File system부터 Disk까지의 행동을 커널 영역에서 다룬다. 음.. 다른 예를 하나더 들어보자. 제목에 socket을 넣어서 잠깐 다뤄보면 우리가 흔히 쓰는 Socket도 결국 위에서 말한 File을 이용한다. 이게 무슨? 소리징하고 처음엔 생각했다. 그 이유는 유닉스의 리소스 구성은 파일로 이뤄져있다. 파일, 하드웨어, 파이프, 소켓등등 밑의 사진을 보면 하드웨어들이 file로 저장되어 있는것을 볼 수 있다. HwfileHwfile \" Hwfile 다시 Socket으로 돌아와서 커널 영역에서 뭘하는지 보면, Socket(file) -\u003e Protocol(TCP/IP) -\u003e Driver -\u003e NIC 이렇게 될듯 하다. NIC는 하드웨어로 랜카드이다. TMI로 NIC -\u003e L2 -\u003e R -\u003e internet이 되겠지요? Kernel 영역에서 하는 일은 위의 예시들로 알 수 있을 것이다. 백신 프로그램을 잠깐 보면 어떻게 동작하는지 짐작 할 수 있을 것 같은데 아까 위에서 File -\u003e 구성요소 -\u003e Driver이렇게 흘러간다고 얘기를 많이 했다. 그 중간에 Filter라는 것이 존재하는데 이 Filter는 구성요서 앞/뒤 쯤 올 수 있다. 이 Filter를 백신 업체에서 제공 해주면 Filtering이 되겠거니 싶다. 물론 Filter를 이용하다 보니 속도는 느려 질 수 있을 것이다. ","date":"2019-11-06","objectID":"/computerstructure/:2:1","tags":["os","linux","socket"],"title":"Computer structure and socket","uri":"/computerstructure/"},{"categories":["os"],"content":"User User영역은 아까 많이 언급한 File이 속한다. 또한 백신 얘기할때 anti virus가 속할 수 있고 이 anti virus는 아까 Filter와 주거니 받거니 할 것이다. ","date":"2019-11-06","objectID":"/computerstructure/:2:2","tags":["os","linux","socket"],"title":"Computer structure and socket","uri":"/computerstructure/"},{"categories":["os"],"content":"Process/Thread 가장 많이 접한 Process와 Thread이다. 이 둘을 간단히 비교해보면 Process안에 Thread가 있고 Thread는 프로세스 내에서 실행되는 여러 흐름의 단위라고 구글에 검색하면 많이 나올 것이다. 엄청 간단히 예시를 들면 집(house)가 Process 그 안의 구성원 엄마, 아빠 등이 Thread라고 생각하면 될 것 같다. Process끼리는 독립된 Memory를 가져서 서로 데이터 공유가 안된다. 물론 Thread는 Process 내에서 동작하기 때문에 Process내의 Thread끼리는 같은 메모리 공간을 이용한다. 따라서 동기화가 중요 하다 ! 실생활의 예를 들어보면 집(process)에 내가(thread) 화장실을 사용하고 있을때 문을 잠그고 이용하게 되면 다른 가족구성원(thread)는 화장실을 사용하지 못한다. 만약, 문을 안잠그고 사용하다가 큰일을 보는 중에 문을 열어버린다던지 그러면 안되는 것 처럼 이해 하면 될 것 같다. 여기서 화장실 문을 잠그는 행위는 Lock을 거는 행위이고 이는 mutex를 이용해 Lock, UnLock을 하는 것과 같다고 보면 될 듯 하다. 여기서 말한 Memory는 아 ~~ 까 말한 S/W는 Virtual == Logical 을 잠깐 인용하자면 Process에 할당된 Memory는 virtual memory이다. ","date":"2019-11-06","objectID":"/computerstructure/:2:3","tags":["os","linux","socket"],"title":"Computer structure and socket","uri":"/computerstructure/"},{"categories":["os","linux"],"content":"linux에서 container가 내부적으로 어떻게 동작하는지 알아보자.","date":"2019-10-27","objectID":"/namespace/","tags":["os","linux","namespace"],"title":"Introduction to Linux Namespaces","uri":"/namespace/"},{"categories":["os","linux"],"content":"linux에서 container가 내부적으로 어떻게 동작하는지 알아보자. namespace는 k8s에서 먼저 많이 접해봤는데, 각각 별개의 독립된 공간인 것처럼 환경을 제공하는 가상화 기술이다. container기술이 이를 통해 만들어 졌다. Linux namespace는 6가지 종류가 있다. UTS IPC PID NS (FS) NET USER ","date":"2019-10-27","objectID":"/namespace/:0:0","tags":["os","linux","namespace"],"title":"Introduction to Linux Namespaces","uri":"/namespace/"},{"categories":["os","linux"],"content":"UTS 독립적인 Hostname할당 현재 hostname은 다음과 같이 알 수 있다. uname -n unshare로 namespace를 만드는데 -u를 주면 UTS가 부모 프로세스와 공유가 안된 상태로 생성된다. unshare -u /bin/bash ","date":"2019-10-27","objectID":"/namespace/:1:0","tags":["os","linux","namespace"],"title":"Introduction to Linux Namespaces","uri":"/namespace/"},{"categories":["os","linux"],"content":"IPC inter process communication IPC는 프로세스간 서로 데이터를 주고 받는 경로를 뜻한다. IPC는 Signal, Socket, pipe, semaphore, file locking, mutex등이 있다. 또한 프로세스간 데이터 교환 및 프로세스와 쓰레드간의 작업을 동기화 하는기능을 제공한다. ","date":"2019-10-27","objectID":"/namespace/:2:0","tags":["os","linux","namespace"],"title":"Introduction to Linux Namespaces","uri":"/namespace/"},{"categories":["os","linux"],"content":"PID Linux에서 실행되는 모든 process들은 각각에 고유한 PID가 부여된다. kernel에서는 이 process들을 Tree 형태로 관리한다. pstreepstree \" pstree 최상위 process는 init process라 하고 PID를 “1\"을 가진다. PID namespace에서 가지는 특징이 이 PID 1프로세스를 독립적으로 추가 할당해 주는 것이다. PID를 1받았다고 해서 init process가 되는건 아니고 init process와 비슷하게 수행된다. 이는 OS에서 systemd 프로세스 뿐만 아니라 PID 충돌없이 실행 가능하게 해준다. ","date":"2019-10-27","objectID":"/namespace/:3:0","tags":["os","linux","namespace"],"title":"Introduction to Linux Namespaces","uri":"/namespace/"},{"categories":["os","linux"],"content":"NS (FS) process Tree의 PID 1프로세스를 분기 시켜도 FS는 그대로 공유하고 있을것이다. 이유는 /proc를 아직 공유하고 있기 때문이다. 새로운 폴더를 만들고 /proc폴더를 mount시켜주면 독립적으로 FS를 관리할 수 있을 것이다. ","date":"2019-10-27","objectID":"/namespace/:4:0","tags":["os","linux","namespace"],"title":"Introduction to Linux Namespaces","uri":"/namespace/"},{"categories":["os","linux"],"content":"NET namespace간 Network 충돌 방지한다. $ ip link list 명령어로 현재 서버의 interface 정보를 확인 할 수 있다. $ ip netns add {namespace} 새로운 namespace를 생성하고 다음과 같이 확인 할 수있다. $ ip netns 독립된 namespace간 내부 통신도 가능한데 자세한건 다음 글에서 작성한다. ","date":"2019-10-27","objectID":"/namespace/:5:0","tags":["os","linux","namespace"],"title":"Introduction to Linux Namespaces","uri":"/namespace/"},{"categories":["os","linux"],"content":"USER 프로세스가 namespace 내부와 default namespace간에 각기 다른 사용자 및 그룹 ID를 가질 수 있게한다. ","date":"2019-10-27","objectID":"/namespace/:6:0","tags":["os","linux","namespace"],"title":"Introduction to Linux Namespaces","uri":"/namespace/"}]